# TODO

## Tooling

- [x] biome (lint + format: tab, double quotes, semicolons, lineWidth 100)
- [x] TypeScript (strict mode, ES2022, bundler moduleResolution)
- [x] vitest (test runner + v8 coverage provider)
- [x] tsup (ESM + CJS dual output, sourcemap, dts)
- [x] changesets (versioning & release, @changesets/changelog-github)
- [x] lefthook (pre-commit: biome check on staged files)
- [x] pnpm@10.14.0 (pinned via packageManager field)

## Phase 1: Core

### 1.1 Project Setup

- [x] package.json — type: module, engines: node>=20, sideEffects: false
- [x] tsconfig.json — strict, ES2022, bundler resolution, declaration + declarationMap + sourceMap
- [x] biome.json — recommended rules, tab indent, 100 char, double quotes, semicolons always
- [x] vitest.config.ts — v8 provider, coverage 100% thresholds (statements/branches/functions/lines)
- [x] tsup.config.ts — entry points (index, integrations/zod, integrations/valibot), ESM+CJS, dts, clean, sourcemap, external: hono
- [x] .editorconfig — tab indent, lf, utf-8, trim trailing whitespace
- [x] .gitignore — node_modules, dist, coverage, *.tsbuildinfo, .DS_Store
- [x] lefthook.yml — pre-commit: biome check on staged *.{js,ts,jsx,tsx,json}
- [x] publishConfig — access: public, provenance: true

### 1.2 CI / CD

- [x] `.github/workflows/ci.yml`
  - push to main + pull_request to main
  - Node.js matrix: 20, 22, 24
  - Steps: checkout → setup pnpm → setup node (cache) → install --frozen-lockfile → lint → typecheck → vitest run --coverage → build
  - `ci-pass` guard job (needs: ci, fails if ci fails)
- [x] `.github/workflows/release.yml`
  - push to main, concurrency control
  - permissions: contents/pull-requests/id-token write
  - changesets/action@v1 for auto release PR creation + npm publish
  - secrets: GITHUB_TOKEN, NPM_TOKEN
- [x] GitHub branch ruleset — require ci-pass on main branch + PR required

### 1.3 Coverage Target

- [x] vitest.config.ts with 100% thresholds on all metrics:
  - statements: 100
  - branches: 100
  - functions: 100
  - lines: 100
- [x] Coverage include: `src/**/*.ts`
- [x] Coverage exclude: `src/index.ts`, `src/types.ts` (re-exports / type-only files)

### 1.4 Type Definitions

- [x] `src/types.ts` — ProblemDetails, ProblemDetailsInput, ProblemDetailsHandlerOptions
- [x] Tests (14 tests): type inference verification via vitest expectTypeOf

### 1.5 Status Code Mapping

- [x] `src/status.ts` — statusToPhrase(), statusToSlug()
- [x] Tests (22 tests): common status codes, unknown status, slug generation

### 1.6 ProblemDetailsError

- [x] `src/error.ts` — ProblemDetailsError class
- [x] `src/factory.ts` — problemDetails() factory function
- [x] Tests (7 tests): F1-F6 + unknown status fallback

### 1.7 Error Handler

- [x] `src/handler.ts` — problemDetailsHandler()
- [x] Tests (17 tests): H1-H15 + defaultType + unknown status via mapError

## Phase 2: Validator Integration

### 2.1 zodProblemHook

- [x] `src/integrations/zod.ts` — zodProblemHook()
- [x] Tests (7 tests): Z1-Z7

### 2.2 valibotProblemHook

- [x] `src/integrations/valibot.ts` — valibotProblemHook()
- [x] Subpath export: `./valibot`
- [x] Tests (8 tests): V1-V7 + root-level validation without path

## Phase 3: Community & Docs

### 3.1 Community Files

- [x] CONTRIBUTING.md — dev setup, commands, TDD workflow, code style (biome), changeset usage
- [x] CODE_OF_CONDUCT.md — Contributor Covenant v2.1
- [x] SECURITY.md — supported versions, report via GitHub Security Advisories, response timeline
- [x] LICENSE (MIT)

### 3.2 GitHub Templates

- [x] `.github/FUNDING.yml`
- [x] `.github/ISSUE_TEMPLATE/bug_report.yml` — version, Hono version, runtime, reproduction steps
- [x] `.github/ISSUE_TEMPLATE/feature_request.yml` — problem, proposed solution, alternatives
- [x] `.github/PULL_REQUEST_TEMPLATE.md` — Summary, Related Issues, checklist (tests/typecheck/lint/changeset)

### 3.3 Packaging

- [x] README.md (English) — RFC 9457 compliance, usage examples, Zod/Valibot integration
- [x] Subpath exports (`.` → core, `./zod` → Zod, `./valibot` → Valibot)
- [x] npm publish (v0.1.0 published)
- [ ] JSR publish
- [x] CHANGELOG.md — auto-generated by changesets

## Phase 4: Publish & Integrate

### 4.1 npm / JSR Publish

- [x] npm publish (v0.1.0 via changesets)
- [ ] JSR publish

### 4.2 Hono Ecosystem

- [ ] Comment on [honojs/middleware #579](https://github.com/honojs/middleware/issues/579)
- [ ] Submit third-party listing PR to honojs/middleware

### 4.3 Existing Library Integration

- [ ] PR to migrate hono-idempotency errors.ts to hono-problem-details
- [ ] PR to migrate hono-webhook-verify errors.ts to hono-problem-details

#### Current State

Both libraries do essentially the same thing in their `errors.ts`:

- `hono-idempotency/src/errors.ts` — returns RFC 9457 JSON directly as Response
- `hono-webhook-verify/src/errors.ts` — returns RFC 9457 JSON directly as Response

Conceptually identical code in each:

```ts
return c.json({
  type: "https://hono-xxx.dev/errors/conflict",
  status: 409,
  title: "...",
  detail: "..."
}, 409, { 'Content-Type': 'application/problem+json' })
```

#### Integration Pattern: Two Options

**Option A: throw + app.onError pattern**

```ts
// hono-idempotency middleware.ts
import { problemDetails } from 'hono-problem-details'

throw problemDetails({ status: 409, title: '...', type: '...' })
// → app.onError(problemDetailsHandler()) catches and returns
```

Problem: requires user to set up `app.onError(problemDetailsHandler())`. Degrades standalone usability of hono-idempotency.

**Option B: getResponse() direct return (recommended)**

```ts
// hono-idempotency middleware.ts
import { problemDetails } from 'hono-problem-details'

const error = problemDetails({ status: 409, title: '...', type: '...' })
return error.getResponse()
// → works without problemDetailsHandler()
```

This is correct. Call `getResponse()` inside middleware to return directly. No dependency on `app.onError`.

#### Trade-off Analysis

| Aspect | Adopt hono-problem-details | Keep current (no change) |
|--------|---------------------------|--------------------------|
| Dependencies | hono + hono-problem-details | hono only |
| Code size | errors.ts ~5 lines | errors.ts ~30 lines |
| Consistency | Unified across 3 libraries | May diverge slightly |
| Content-Type | Guaranteed `application/problem+json` | Manual per-library (risk of omission) |
| Version coupling | Breaking changes in hono-problem-details propagate | Independent |
| User overhead | `npm i hono-problem-details` as transitive dep | None |

#### Recommended Approach: Staged Adoption

**Phase 1 (at v1.0 release): Do not adopt**

- Release and stabilize hono-problem-details independently first
- hono-idempotency / hono-webhook-verify keep their own errors.ts
- Reason: adopting before API stabilizes creates version coupling risk

**Phase 2 (after hono-problem-details v1.0 stable): Add as optional peerDependency**

```jsonc
// hono-idempotency/package.json
{
  "peerDependencies": {
    "hono": ">=4.0.0",
    "hono-problem-details": ">=1.0.0"
  },
  "peerDependenciesMeta": {
    "hono-problem-details": { "optional": true }
  }
}
```

> Note: Each library's errors.ts is only ~20-30 lines. The benefit of adopting is less about code reduction and more about ecosystem branding — having hono-problem-details in the npm dependency graph naturally increases user awareness, leading to adoption in their own `app.onError` setup. The marketing value outweighs the technical value.

## Stretch Goals

- [x] OpenAPI integration (`hono-problem-details/openapi`) — ProblemDetailsSchema, createProblemDetailsSchema, problemDetailsResponse for @hono/zod-openapi
- [x] Standard Schema integration (`hono-problem-details/standard-schema`) — standardSchemaProblemHook for @hono/standard-validator
- [x] i18n — `localize` callback on ProblemDetailsHandlerOptions for title/detail localization
- [x] Problem type registry — createProblemTypeRegistry() for type-safe error creation
- [ ] Express adapter — alternative to express-http-problem-details
